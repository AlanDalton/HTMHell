---
title: "The hidden attribute in HTML"
layout: layouts/advent.md
author: "Ahmad El-Alfy"
author_bio: "Bio"
date: 2023-12-15
tags: advent2023
author_links:
  - label: "website"
    url: "https://site.com"
    link_label: "site.com"
active: true
intro: "<p>intro</p>"
status:
  review_manuel: "done"
  review_eric: "done"
  review_saptak: "done"
---
<!-- Manuel:
You mix forms of address. You talk about "authors", but you say "adding this snippet to your…" and most of the time you talk about "we" like "we need to toggle the display". Please choose one form, adress the reader either with "you" or "we". -->


The `hidden` attribute allows authors to hide HTML elements from the page. When it was introduced, it worked in a very simple way: it set the CSS `display` property to `none`.
<!-- Manuel: I've combined the original two sentences because you were saying the same thing twice. -->

Many people voiced concerns because here we are, mixing styles with markup again. To be fair, this was at a time before the rise of frameworks and the change in people's mindsets where separation of concern became a less debatable issue. There were also others who opposed the attribute because it can be easily overridden by CSS. A solution to avoid hidden elements from showing unintentionally is adding this snippet to your stylesheet to ensure it overrides other rules used on the same element.

<!-- Manuel:
1. "many people voiced concerns" <-- Can you find a link to an early discussion or tweet or similar? -->

<!-- Eric: Same sentiment as Manuel for "There were also others" -->

```css
[hidden] {
  display: none !important;
}
```

However, there were differing opinions on using the `!important` declaration, as some authors considered it code smell. However, later the use of `!important` in utility classes became more accepted.

<!-- Eric: Both of these sentences start with "However,". Can we remove one? -->

<blockquote>A modern way to mitigate the use of <code>!important</code> is the use of CSS layers. CSS layers is implemented by using the <code>@layer</code> directive, allowing us to define specific layers for our styles. This allow us to control the specificity and ordering of the CSS rules without resorting to <code>!important</code>. This approach promotes a more maintainable and scalable codebase, reducing the reliance on <code>!important</code> declarations and making it easier to manage styles across different components and elements. All we need to do is to add the previous snippet in the utility layer and moving that layer to be the last. This way we can ensure that their styles take precedence without the need for <code>!important</code>.</blockquote>
<!-- Manuel: source? -->

<!-- Eric: Unsure if you'll touch on this, but there's also the consideration of !important as a way for force immutability. Very helpful for a conditionally-applied attribute selector like `[hidden]`. -->

Let's take an example where we need to toggle the display of an element. We can do that by setting its `display` property to `none` using JavaScript and inline CSS. This is a common approach that many follow to hide an element instantly. To show the element again we can change the display back to whatever value we want.

```javascript
// Hide the element
el.style.display = 'none';

// Show the element again by setting the display to another value
el.style.display = 'block';
```

The problem with setting the display to something other than `none` is that we could be dealing with an element that has different display values according to the media size for example (e.g. `block`, `flex` ... etc). In that case, setting it to a specific value can introduce some troubles if the display types don't match.

Another approach would be to use the `removeProperty` method, available on the elements `style` property, which removes specific inline styles.

```javascript
// Show the element again by removing the inline declared property
el.style.removeProperty('display');
```

One argument in favor of the `hidden` attribute is its semantic value. It clearly indicates that an element using the attribute is intended to be hidden from display. So without having to set inline style, we can add and remove the attribute on the element as we want.

```javascript
// Hide the element
el.hidden = true;
// We can also use addAttribute
el.setAttribute('hidden', '');

// Show the element
el.hidden = false;
// We cal also use removeAttribute
el.removeAttribute('hidden');
```

<!-- Manuel: another argument is that it enables you to hide content from everyone without needing CSS. -->

## The future of `hidden` attribute

Initially, the `hidden` attribute was considered a boolean attribute. If the attribute was present on an HTML element, it would be effective regardless of its value:

```html
<div hidden>This element will be hidden</div>
<div hidden="hidden">This element is also hidden</div>
<div hidden="false">This one is hidden as well</div>
```

However, the specification has changed recently, and the `hidden` attribute is now an enumerated attribute. This means it can have specific named values. One new value introduced in the specification is `until-found`, which triggers a new state called the "Until Found" state.

<!-- Saptak: Can you link to the changed specifications -->

```mermaid
flowchart TD
A[Element] -->|"hidden" Attribute| B(Attribute Value)
B -->|until-found| C[Until Found State]
B -->|No Value| D[Hidden State]
B -->|Empty String| D
B -->|Any Value| D
```
<!-- Manuel: Do we really need this? I find it more confusing than useful. -->

<!-- Eric: Mermaid charts aren't accessible. I'd recommend rendering it in a GitHub preview, screenshotting it, and then suppling it as an image with an alternate description. -->

## The hidden until found state

The hidden until found state was created to solve a common problem. Let's look at tabs and accordions for example. These UI components contain elements that are inaccessible until a certain action is done (e.g clicking a button). This makes the content unavailable to screen readers, search engines, and the built-in find-in-page feature in browsers.

<!-- Manuel: is until-found really suitable for tabs and accordions? once the content is visible, you can't hide it anymore unless you set the attribute again with JS, right? -->

<!-- Eric: Nit, but inacessible and undiscoverable are two different things. Inacessible is it can't be used by an assistive technology user, while undiscoverable means it exists, but nobody can locate it. -->

<!-- Saptak: +1 to what Eric said -->

Unlike the standard "hidden" state, which completely hides the content by setting its `display` property to `none`, the "hidden until found" state uses the `content-visibility` property to hide content while still making it accessible to search engines, find-in-page functionality, and linking. Consider the following example (currently only supported in Chrome and Edge).

<iframe width="100%" height="500" src="https://livecodes.io/?x=code/N4IgLglmA2CmIC4QAkIBM2wHYAICCYYAThAEYCuY8ANCJgM4DGJADpAPZaIgi1gCGAc3qIA2gF1a-RpABusAKJoo7ItyaswvEAFt+RANbkWiUNH5ZB5IfCQALMDujbGnKli1IAPAEIAIgDyAMIAKgCaAAoKOA5OAHwAOlhesdA45pYAvAkg2DmJyXaw-GgFODheOrACOIx2+vTV2SAAqiEAYgC0ABz5SeWV1fwxhCydsACO5BCyzQAanS14nUHsOiz8kKRwObVu2GDNAJIKmbBogrB9uBVVNVj8Vc2yELAA7iyqYLuuHgfNb3QYDsmUwL0YsE6gLQwOoOAgWCgEH40E6TBRsEyAEYAHQABmuA0gMFgcT87EY5CqHi8AHpiXACnSiiUmaR2GgAJ5lCp2LFxABCFmFzP5SXFYBSACY4kcsJgAB7MmUSrzkaA8gbQCBxLzDOxEWAAM2aAGIEcR2Pk5Za0OQZBBOHT+LradqCglvpL3XqYoaTTlTQxmBA2I6sPk-LANKGOMlaS66e6JZ6vD79f6zdVOTp2NB2IJOfkFGAc3mC5zna7kxHJbT1R6bl5lLJ4WhmhaiFaQDF0JgsM1yB4IKijewh2hCeUKiw4ngcKRhQ94fQcBYcLB85ZNuc4ecyHAcEaiNMwDhAMgEC-YAkRjBR0E5a4XsCIRE5oix4lEUvEF5wLC7O0ITQBdH0aeQiBRHADARNBV3YI10n0S4YhfRcIXHVcjXzN4XwRQR-wyMBVwRHBgVgHBLiwchVwAWRo-gcVEABmX85Rweg1go1wh2IV56DhRcHgeVcaPOI9VD2dgYMsHA9EfUhuPvcSchYIj+ARegcjhZR6EgSxpnoOx8LIoodCPLtzIYRoiDPIThXoHEcBCIoLNPFccFkfRkW2CjSPoCAAC9YDhVx8yIOELBAo0ICIHQsGjASF0oDyaOsaAHw3LdBB3ECotqcgiHkNA4UBYEOIQs9sOjOwcBIOp4VwPT9Aa1wIPEsrauGEh5VK4yGvk59KMNbA4U5TccLhQ0Sv-Qq1JCnBJNILs3lwN4ilwVhYCclyKOPU9V0EFacGMN59BA0jGGgGiqCIVcEv0UyKLAdgWEWxDyMIiwwCcvBoFzPS1wyuSORfXB918jjYHOOB6FXAAKDZbI2il9BYABKBcl34VdXCqCy1jIt52BwQFoBA+gWFgRh+L-ej6GGaQqQRTZGflHB6eGRdoFICAAuFHbXKYV5hxixgcAeKp4MQgGz0paA5FyrHhJxtdDQ5hi10pHQWYEOFOaxnm+eRB5IvZg2AHX-30EpjekYYxyIJ6Yk5Zb0A1hmteZh4ait2inO53n+dNnBMCp+UTM4J7Yso7A1ggcXfj0qBKHDQWKLzCmaYOCAxYlx49sk4E+Zdt2ZoNhmWBFsAqThEusBJ7KXxOxo0DpWd+gqWkW0bVMWzbZpg00cNdmMjBsEHYdR3HeVrk9VM7BlKMYzDJ1aUXj0vS8WdduV4Uvo8DzPvMIhLkBooiHQ2BMKPHC8NktTvqYrE8V-P60k+-h2XkTojpnkCkbEXek+eyy5H6Hz-m8Am5lhh6RPDIQqFE0r3kfHeDK4lhg5FcHFHIz9Pw4AiERVc+gKINziigsi941zsyNBpIgmU9KFS5KTKAXUyIjW1AYCi-AWBUxtlgCEgkUrrU2GuXhxQ7pkRJopJ8xAhwGA8tIGuFDMEgFodARoHEqA6F2JJFgjRyBoHYHpWAOgnJChVodY6pFhjQgol5Eg2ZgGcRHElVW2U1yrk+i4tIJdRFwBxmeAAbHiWoOc7iGgRlKfER4wCY0wLAFgcJ6iHXYByUOkEWYoXyvXa8ex1hKPOM-H8OALH73AUAkha5cyyU+rQkxgNIGR0QlQipSVOqhw0gwwqtCITDXYG8cqkEqCrkNNgzAIEEI4FxAAFg4lMKpETow4HhliAArPM2JmMXrTJxEE+Z1h1ZLIRliAA7Jso0cTn6sQ-DM8Q7dN50h7uKWszYZgDxyNmXM+ZCyjz7BPHIvERydDHBOOeW8N4ljLD8ys68VS1lTDvVyxMiAgRyKA-guwS7AnHIIBwUihpTIAOrRjPHgY8Cd1yqAgIIBEcJPhwwPI+Y8hNPpEvLIhFFIF7LCjNgAnGrdGo7IUJYbURlPLIhwAAZQ2IicVkkIhfHIFYaM20WJ3JYms+5tIO6vO7jMXukoKCECjqWKmzRjUvQjCAOIAAlVVZ4-B80frCy1nAmS0nZFyD1qQ4ggAAL60D0pyOApgQAZCsDYbgjA4YuH2B4bgAag0hjYGGiN1hLjcAAFb8C8ivLQtBfjuE8CAXOKyfDwwAOScEUo7Uxmw6iVsaqHCkVIDg4i9ZydGmNgCdyTmeM6RBESyUyC27W7bmDFCoAoOA1IwBVpYJW9GABuTug7h2CBxAiBKRAQiwAVGeUdAADFyJdloDJsi25ZDczz0GMJ8WyztK1AunhOJtXlrqFydp9Me-Y1yEBIMa7aR7V03CMeOjwHaOSchxABRJ2A0Dw3XfhdGSR-UvP7clE1uBR3gbbZBqYL5ORSs3NTF6RAq1uqwEu0DSQqM4hKGgBQ8gPAABk+buBfFWq6CcDCVrhPDTGmQ4g4F7QisAeG504kI2+EjcAZCqHflW0Q6BxBLpxI7BQ0g7Dw3hpuITImxPzy9JuHEjQwAED4kBqtv7sD8ZwM+qeIL-40YlP61DWB3NJpAMG2GRRqgiAQBIZNmhAvBZADG+gERInVETbQACFJEqqDC5ICLN01gkcIPhQLwBA2lvWF8HLeWzXRlMMV0lOXw0WEjZmpAJX81xr+AmpA3mIIBU4NwdZAagA"></iframe>

<!-- Manuel: can you show the HTML tab by default? -->

In this example, try using the browser's search feature (find-in-page) and type the word "banana." After the first result is highlighted, attempting to navigate to the next result will reveal the "Introduction" section. Following that, the subsequent sections will become visible in sequence. Clicking the "Reset Display" button will hide the sections again, enabling you to retry the process. Additionally, clicking any of the links will automatically display the corresponding sections.

<!-- Manuel: Before you explain what the "Reset Display" button does, you should mention that once an element is visible, it won't hide again. That
would make clear what hidden until found does. -->

Note that this example doesn't rely on JavaScript, except for the functionality used to reset the display. Instead, the behavior is achieved purely with HTML. As the corresponding sections are "found," the hidden attribute is automatically removed from the elements, triggering their visibility.

<!-- Manuel: You could close the article by talking about browser support. Do Firefox and Safari plan to implement it. Is there a road map?  -->

<!-- Eric: Similarly, have we tested this with assistive technology for how it handles things like the virtual cursor? -->

<!-- Eric: I think we also need a conclusion here. The post ends abruptly, and I'd like to see a short summary that remphasizes _why_ this is important and worth writing about. -->

